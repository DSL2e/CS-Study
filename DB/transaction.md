# 트랜잭션

> 컴퓨터 과학 분야에서 트랜잭션(Transaction)은 "더이상 분할이 불가능한 업무처리의 단위"를
의미한다. 
>
이것은 하나의 작업을 위해 더이상 분할될 수 없는 명령들의 모음.
즉, 한꺼번에 수행되어야 할 일련의 연산모음을 의미한다.
>
데이터베이스에서 트랜잭션을 통해 일련의 작업이 완전히 완료되거나 전혀 실행되지 않는 것을 보장함으로써 시스템의 일관성과 무결성을 유지한다.

## 1. 개요
### 1-1. 트랜잭션 (Transaction)
- 일관성을 유지하는 단위
- 수많은 사람들이 동시에 데이터 베이스를 이용해도 일관성을 유지해야한다.


### 1-2. 동시성 제어 (Concurrency Control)
- 동시에 수행된 트랜잭션들이 마치 순차적으로 시행된 결과와 같도록 보장해주는 것
- 많은 사용자가 데이터베이스를 동시에 접근하도록 허용함과 동시에 데이터베이스의 일관성을 유지한다.

### 1-3. 회복 (Recovery)

- 데이터베이스 업데이트 도중 시스템이 고장나더라도, 데이터베이스의 일관성을 유지해야 한다.

---

## 2. 트랜잭션의 특징 (ACID)

트랜잭션의 안정성을 보장하기 위한 4가지 특성을 각 특성의 앞글자를 따 ACID라고 부른다.

![](https://velog.velcdn.com/images/jjbin/post/59e721cb-6d14-4b04-a24c-ff553f12ace0/image.png)


### 2-1. 원자성 (Atomicity)

- 모든 트랜잭션은 원자 단위(더 이상 나눌 수 없는 작업 단위)로 이루어져야 한다
- 트랜잭션의 모든 연산이 모두 수행되거나 모두 수행되지 않아야 한다.
	- **All or Nothing**

### 2-2. 일관성 (Consistency)
- 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가진다.

- 일관된 상태에서 트랜잭션이 수행된 결과는 또 다른 일관된 상태여야 한다. 

_일관된 상태 : 데이터베이스의 각종 규칙, 제약 조건 등을 준수하는 상태_

#### 일시적 불일치
트랜잭션이 수행되는 도중에는 일시적으로 일관된 상태를 갖지 않을 수 있다.
    
![](https://velog.velcdn.com/images/jjbin/post/ee11ce1f-4f7d-4228-b7ac-65058e350af3/image.png)

    

### 2-3. 고립성 (Isolation)

- 트랜잭션이 수행중인 영역은 고립되어 있어야 한다
    - 트랜잭션 작업 영역은 해당 트랜잭션을 제외하고 접근 불가능해야 한다.
    

- **동시에 다수의 트랜잭션을 수행한 결과는, 트랜잭션들을 어떤 임의의 순서로 순차적으로 실행시켰을 때의 결과와 같아야 한다.**
    - DBMS의 동시성 제어 모듈이 이를 보장한다.
    - DBMS는 다양한 고립 수준(isolation level)을 제공한다.

### 2-4. 지속성 (Durability)

- 작업이 완료된 트랜잭션의 결과는 누락되지 않는다.
    - DMBS의 회복 모듈이 이를 보장한다.
    - 심지어 시스템이 다운되더라도 누락되지 않는다.
    
---

## 3. Commit & Rollback
트랜잭션에서는 데이터의 무결성을 보장하기 위해 Commit과 Rollback 명령어를 사용한다.

![](https://velog.velcdn.com/images/jjbin/post/e4ddd2e5-1fcf-4d70-b9f8-c16b46e01e25/image.png)

- COMMIT : 트랜잭션이 성공적으로 완료되었고 DB에 그 결과과 영구적으로 반영됨.
- ROLLBACK : 트랜잭션이 도중 작업이 실패한 경우, DB를 트랜잭션 수행 이전 상태로 되돌린다.

![](https://velog.velcdn.com/images/jjbin/post/4e0d2bb8-a3c8-4134-896a-e913734144ef/image.png)


### 3-1. 트랜잭션이 성공하지 못하는 경우

- 시스템(사이트) 고장 : 중앙 처리 장치, 주기억 장치, 전원 공급 장치 등이 고장난 경우
- 트랜잭션 실패 : 트랜잭션이 수행되는 도중에 철회되는 경우
- media failure : 디스크 헤드, 디스크 컨트롤러 등이 고장 나서 보조 기억 장치의 전부 또는 일부 내용이 지워진 경우
- 통신 고장
- 자연적 재해
- 부주의 또는 고의적인 고장

---

## 4. 동시성 제어 (Concurrency Control)
여러 사용자들이 다수의 트랜잭션들을 동시에 수행하는 환경에서 부정확한 결과를 생성(트랜잭션들 간의 간섭)하지 않도록 제어해야 한다.

### 4-1. Transaction Schedule
>동시에 실행되는 트랜잭션들의 실행 순서를 정하는 방법

#### Serial schedule (직렬화)
- 여러 트랜잭션들을 하나씩 순차적으로 수행한다.
- 안정성은 높지만 처리량이 낮다.

#### Non-serial schedule
- 여러 트랜잭션들을 동시에 수행한다
    - 실제로는 Time Slicing으로 매우 빠르게 번갈아 가면서 수행하는 것

#### Serializable schedule
- Non-serial schedule의 결과가 직렬화 결과와 동등함을 보장한다.

### 4-2. 이상 현상
동시성 제어를 하지 않으면 다음과 같은 이상현상들이 나타날 수 있다.

#### Lost update

- 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어써 갱신 내용이 사라지는 경우.

![](https://velog.velcdn.com/images/jjbin/post/6f2001e4-3bf7-4a22-8ee5-825e63fc1dc4/image.png)

#### Dirty read

- 다른 트랜잭션에서 아직 커밋되지 않은 변경 사항을 읽는 경우.

![](https://velog.velcdn.com/images/jjbin/post/d485027f-8bba-4eb5-8620-48fef5939140/image.png)


#### Non-repeatable read

- 같은 트랜잭션 내에서 동일한 데이터를 여러 번 읽을 때, 읽을 때마다 값이 다른 경우.

![](https://velog.velcdn.com/images/jjbin/post/2879645f-bae3-42b7-bc22-ad723139967c/image.png)

#### Phantom Read
- 같은 트랜잭션 내에서, 여러 레코드를 같은 조건으로 여러 번 읽었을 때, 결과가 다른 경우.
	- 첫 번째 조회에서는 없던 데이터가 두 번째 조회에서 생기는 현상


### 4-3. 격리 수준 (Isolation Level)
시스템의 일관성과 성능 간 트레이드 오프에 따라 다음과 같은 격리 수준을 선택할 수 있다.

#### READ UNCOMMITTED
가장 낮은 격리 수준을 갖는 단계로써, 한 트랜잭션이 수행한 아직 커밋되지 않은 작업의 결과를 다른 트랜잭션이 읽을 수 있다.

- Dirty Read, Non-Repeatable Read, Phantom Read 발생 가능성 존재

#### READ COMMITTED
대부분의 데이터베이스에서 기본적으로 사용되는 격리 수준으로, 트랜잭션은 커밋된 데이터만 읽을 수 있다.

- Non-Repeatable Read, Phantom Read 발생 가능성 존재

#### REPEATABLE READ
이 격리 수준에서는 한 번 lock이 설정된 레코드는 해당 트랜잭션이 종료될 때까지 lock을 유지한다. 따라서 트랜잭션에서 같은 데이터를 반복해서 읽으면 항상 같은 결과를 반환한다.

하지만 트랜잭션 중 조건에 해당되는 새로운 레코드가 추가될 경우에는 그 결과가 달라질 수 있다.
- Phantom Read 발생 가능성 존재

#### SERIALIZABLE
가장 엄격한 격리 수준으로, 여러 트랜잭션들을 순차적으로 실행시킨다. 데이터 부정합 문제가 발생하지 않지만 동시성이 매우 떨어진다.

---

## 5. Locking

데이터베이스는 Lock 메커니즘을 사용하여 격리를 구현하고, 트랜잭션 간의 동시 접근을 제어한다.

Lock은 트랜잭션이 서로 간섭하는 것을 방지하며, 트랜잭션이 실행 중일 때 리소스(예: 행, 페이지 또는 테이블)에 대한 접근을 제한한다.

- lock 대상 : 데이터베이스 내의 각 데이터 항목과 연관된 변수
- lock table : 트랜잭션을 수행하기 시작하면, 데이터에 접근할 때마다 요청한 lock과 관련된 정보는 lock table에 유지된다.


### 5-1. Lock 종류
#### S-lock (Shared lock) : 공유 락
여러 트랜잭션이 동시에 읽는 것을 허용한다.
    - 읽기 작업은 여러명이 수행해도 상관이 없다.
    - 여러 트랜잭션이 동시에 동일한 리소스에 대한 s-lock을 획득할 수 있다.
    
s-lock이 걸린 리소스에 다른 트랜잭션의 쓰기 작업을 제한한다.
    
#### X-lock (eXclusive lock) : 독점 락, 배타 락
하나의 리소스에 한 트랜잭션만 x-lock을 획득할 수 있다.
다른 트랜잭션들이 해당 리소스에 읽기 및 쓰기 작업을 수행하는 것을 제한한다.

#### unlock
트랜잭션의 모든 데이터 접근이 종료 되면 모든 lock들을 해제한다.
- lcok table에서 해당 lock에 관한 record가 삭제된다.

![](https://velog.velcdn.com/images/jjbin/post/b3cef310-1337-49b2-8747-44ed4965f64d/image.png)



### 5-2. Multiple granularity locking (다중 세분화 잠금)
대부분의 트랜잭션들이 소수의 튜플들에만 접근하는 경우 튜플 단위로 locking을 해도 lock table을 다루는 데 그리 오랜 시간이 걸리지 않는다.

하지만 트랜잭션이 많은 튜플들에 접근하는 경우, 튜플 단위로 locking한다면 lock table에서 충돌을 검사하고 lock을 기록하는데 너무 오랜 시간이 걸린다.

=> 트랜잭션에서 접근하는 튜플의 수에 따라 lcoking하는 데이터 항목의 단위를 나눌 필요가 있다.
 
일반적으로 DBMS는 각 트랜잭션에서 접근하는 튜플 수에 따라 자동적으로 lock 단위를 결정한다.
- Lock units은 database, relation, disk block, tuple 등으로 구성된다.

- Lock units 따른 trade off가 존재한다.
	
    - 락 단위가 작을수록 락에 따른 오버헤드가 증가한다.
    - 락 단위가 작을수록 동시성의 정도 또한 올라간다.
    
- 한 디스크 블록 안에 t1,t2 튜플이 존재하고 서로 다른 두 트랜잭션이 각각 t1과 t2에 대해 lock을 요청한다고 하자.
    - 락 단위가 튜플이라면 동시에 접근 가능하지만, 블록 단위라면 서로 다른 튜플을 원하는데도 불구하고 같은 블록을 원하기 때문에 누군가는 대기해야 된다.
    - 락 단위가 클수록 락테이블의 작업 시간이 줄어들지만 위와 같은 단점들이 생긴다
    - 클 때와 작을 때 모두 trade off가 있다 → 트랜잭션이 요청하는 튜플에 따라 잘 결정해야 한다.

![](https://velog.velcdn.com/images/jjbin/post/b71ab172-2d49-42b5-b4b9-2f212583d271/image.png)

---

## 6. 회복 (Recovery)
**트랜잭션 회복(Transaction Recovery)**은 데이터베이스 시스템에서 트랜잭션이 실패하거나 시스템 오류가 발생했을 때, 데이터베이스를 일관된 상태로 복구하는 과정을 의미한다.

예를 들어 트랜잭션을 수행하는 도중 시스템이 다운되어 일부만이 database에 저장되었을 수 있다.
- 이 때, 트랜잭션의 수행을 취소하여 원자성을 보장해야 한다.

트랜잭션 수행 직후 시스템이 다운되어 갱신된 내용이 메모리에서 디스크로 옮겨지지 않았을 수 있다.
- 이러한 경우에도 지속성을 보장해야 한다.
- = 완료된 트랜잭션의 수행 결과를 데이터베이스에 반영되도록 해야한다.
<br>

#### 트랜잭션이 완료되었다고 곧바로 실제 DB(디스크)에 기록되는 것은 아니다.
DB는 빠른 연산을 위해 연산 결과를 우선 메모리에 기록하고 주기적으로 하드디스크에 메모리 정보를 동기화 한다.
- 메모리에 우선 갱신한 뒤, 한번에 디스크에 쓰는 것이 성능이 좋다.
    - 디스크에 비해 메모리 접근 속도가 훨씬 빠르다.
    - 디스크에 여러 작업을 한번에 쓰는 것은 디스크 접근 시간에 비하면 오래 걸리지 않는다.

- 따라서 메모리 버퍼에 기록된 내용을 디스크에 옮기는 횟수를 최대한 줄이는 것이 일반적이다.
    - ex) 메모리에 버퍼가 가득 찼을 때
    - ex) 트랜잭션이 완료되었을 때(강제기록)


### 6-1. 회복 매커니즘 (Redo & Undo)
트랜잭션 회복 메커니즘의 기본 목표는 데이터베이스를 **일관된 상태(Consistent State)**로 되돌리는 것입니다. 이를 위해 트랜잭션이 **커밋(Commit)**된 경우에는 그 결과를 반드시 유지해야 하며, **롤백(Rollback)**된 경우에는 그 트랜잭션의 변경 사항을 모두 취소해야 합니다. 회복을 위해 데이터베이스는 다음과 같은 원칙을 따릅니다:

Redo(재실행): 커밋된 트랜잭션의 변경 사항을 복구하기 위해 다시 실행합니다.
Undo(취소): 실패한 트랜잭션의 변경 사항을 취소하고 원래 상태로 복구합니다.

트랜잭션이 메모리에는 갱신 내용을 반영 했지만, 디스크에는 쓰지 못했을 수 있다.

- 시스템이 다운 되기 전 트랜잭션을 완료(Commit)했다면, 지속성을 보장하기 위해 갱신 사항을 재수행(**REDO**)한다.
    
- 완료하지 못했다면, 원자성을 보장하기 위해 일부 반영된 트랜잭션의 내용들을 취소(**UNDO**)해야한다.

### 6-2. 재해적 고장과 비재해적 고장

#### 재해적 고장
- 디스크가 손상을 입어서 데이터베이스를 읽을 수 없는 고장
- 재해적 고장으로부터의 회복은 데이터베이스를 백업해 놓은 자기 테이프를 기반으로 한다.
    - 주기억 장치와 같은 휘발성 저장 장치에 들어 있는 내용은 시스템이 다운된 후에 모두 사라진다.
  - 디스크와 같은 비휘발성 저장 장치에 들어 있는 내용은 디스크 헤드 등이 손상을 입지 않는 한 시스템이 다운된 후에도 유지된다.
  - 두 개 이상의 비휘발성 저장 장치가 동시에 고장날 가능성이 매우 낮으므로 비휘발성 저장 장치에 두 개 이상의 사본을 중복해서 저장함으로써 안전 저장 장치를 구현한다.
    - **안전 저장 장치(stable storage)** : 모든 유형의 고장을 견딜 수 있는 저장 장치
    
#### 비재해적 고장
- 재해적 고장이 아닌 나머지 유형의 고장
- 대부분 회복 알고리즘들은 비재해적 고장에 적용된다.
- 로그를 기반으로 한 갱신(즉시 or 지연), 체크포인트(Checkpoint), 그림자 페이징(shadow paging) 등의 회복 알고리즘들이 있다.
  - 상용 DBMS에선 대부분 로그 기반 갱신을 사용한다고 한다.

---
    
## 7. 회복 기법

### 7-1. 로그를 기반으로한 갱신

트랜잭션의 원자성과 지속성을 보장하기 위해 DBMS는 **로그(Log)**라고 부르는 특별한 파일을 유지한다.
- 트랜잭션의 갱신 사항을 메모리의 로그 버퍼에 기록한다
- 메인 메모리에 데이터베이스 버퍼보다 로그 버퍼를 항상 먼저 디스크로 내보낸다
- 로그는 데이터베이스 회복에 필수적이므로 일반적으로 **안전 저장 장치에 저장**된다.
        
 ![](https://velog.velcdn.com/images/jjbin/post/bc79a06f-eab2-46c8-afd9-621a94fab7f5/image.png)

        
- 각 로그 레코드는 **로그 순서 번호(Log Sequence Number, LSN)**로 식별된다.
    - 주기억 장치 내의 로그 버퍼에 로그 레코드들을 기록하고 **로그 버퍼가 꽉 찰 때** **디스크에 기록한다**.
    - 각 로그 레코드가 어떤 트랜잭션에 속한 것인가를 식별하기 위해서 **각 로그 레코드마다 트랜잭션 ID를 포함**시킨다.

#### 로그 레코드 종류 (Type of log record)
![](https://velog.velcdn.com/images/jjbin/post/0fb0e655-af40-4154-b4ba-b7debab6c2a8/image.png)

#### 로그 기록 예시
![](https://velog.velcdn.com/images/jjbin/post/ebec94fd-57ee-486c-85f7-9d93ebd8d459/image.png)

로그 순서 번호를 보면 T1이 먼저 수행되고 T2가 수행됨

- T1 로깅 과정 살펴보기
    - 트랜잭션 생성 -> [T1, start]
    - B,C,A 순으로 write_item수행했음. 작업 수행 시점에서 old값과 new값 기록
        - B = B(300) + 100 -> [T1, B, 300, 400]
        - C = 2 * C(5) -> [T1, C, 5, 10]
        - A = A(100)+30+B(400)+C(10) -> [T1, A, 100, 540]
    - 트랜잭션 완료 -> [T1, commit]


#### 커밋 지점 (Commit point= 트랜잭션 완료 지점)
- 한 트랜잭션의 데이터베이스 갱신 연산이 모두 끝나고 **데이터베이스 갱신사항이 로그에 기록된 시점**
#### All or Nothing
- DBMS의 회복 모듈은 로그를 검사하여 로그에 [Trans-ID, start] 로그 레코드와 [Trans-ID, commit] 로그 레코드가 모두 존재하는 트랜잭션들은 재수행(REDO)한다. 
- [Trans-ID, start] 로그 레코드는 로그에 존재하지만 [Trans-ID, commit] 로그 레코드가 존재하지 않는 트랜잭션들은 취소(UNDO)한다.

#### 회복 과정
로그 레코드를 회복 모듈이 참조하여 Redo 혹은 Undo 작업을 수행한다.
![](https://velog.velcdn.com/images/jjbin/post/e8e7ba24-31da-4e27-bccf-a0e8bd5231a3/image.png)

아래 로그 기록 참조

![](https://velog.velcdn.com/images/jjbin/post/5ec1a9a3-9d56-4ac5-a64a-e572d8567cd5/image.png)



### 7-2. 체크포인트
회복시 **재수행할 트랜잭션의 수를 줄이기 위해서** 주기적으로 체크포인트를 수행한다.
    
**체크포인트 시점에는 주기억 장치의 버퍼 내용이 디스크에 강제로 기록**되므로, 체크포인트를 수행하면 **디스크 상에서 로그와 데이터베이스의 내용의 일치**하게 된다.

- DBMS가 로그를 사용하더라도 어떤 트랜잭션의 갱신 사항이 주기억 장치 버퍼로부터 디스크에 기록되었는가를 구분할 수 없다.
- 시스템이 다운된 시점으로부터 오래 전에 완료된 트랜잭션들이 데이터베이스를 갱신한 사항은 이미 디스크에 반영되었을 가능성이 크다.
⇒ **주기적으로 중간중간 디스크에 저장해놓자**
- 체크포인트 작업이 끝나면 로그에 **[checkpoint] 로그 레코드가 기록**된다.



#### 체크포인트 수행절차

1. 수행중인 트랜잭션들을 일시적으로 중단 시킨다.
    - 회복 알고리즘에 따라서 이 작업이 필요하지 않을 수 있다.
2. 메인 메모리의 로그 버퍼를 디스크로 강제 출력한다.
3. 메인 메모리의 데이터베이스 버퍼를 디스크로 강제 출력한다.
4. [checkpoint] 로그 레코드를 로그버퍼에 기록한 후 디스크로 강제 출력한다.
5. 체크포인트 시점에 수행 중이던 트랜잭션들의 ID도 [checkpoint] 로그 레코드에 함께 기록된다.
6. 일시적으로 중단되었단 트랜잭션들을 재개한다.

**without checkpoint**

![](https://velog.velcdn.com/images/jjbin/post/7d45a900-b1ae-4de4-bc1f-e4b824873088/image.png)


- T2,T6는 커밋로그가 없으므로 롤백시킨다.
- T0,T1,T3,T4,T5는 재수행한다.

**with checkpoint**

![](https://velog.velcdn.com/images/jjbin/post/bd24547b-4884-4c0f-95f8-aee778505de7/image.png)


- T0,T1,T3 는 체크포인트로 이미 디스크에 기록되었으므로 무시한다.
- T2,T6는 완료되지 않았으므로 롤백시킨다.
- T4, T5는 재수행한다.

---

# References.

> 
Keith Ross, Kurose, James, 『computer networking a top-down approach 8th』, Pearson Education Limited
> 
[이하눌, 『견고하게 트랜잭션 스케줄(Transaction Schedules) 개념 잡기』, le2ksy.tistory.com](https://le2ksy.tistory.com/6)
> 
[forestlim, 『[DB] Dirty Read, Non-Repeatable Read, Phantom Read 예시 및 Snapshot Isolation Level | LIM』, amazelimi.tistory.com](https://amazelimi.tistory.com/entry/DB-Dirty-Read-Non-Repeatable-Read-Phantom-Read-%EC%98%88%EC%8B%9C-%EB%B0%8F-Snapshot-Isolation-Level-LIM)


